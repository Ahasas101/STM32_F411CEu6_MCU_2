#include "stm32f4xx_hal.h"
#include <stdio.h>
#include <string.h>
void Timer2_init(void);
void Error_handler(void);
void SysClk_config(void);
void GPIO_SWO(void);

uint32_t pulse1_value = 16000; // to produce 500hz
uint32_t pulse2_value = 8000; // 1000hz
uint32_t pulse3_value = 4000; // 2000hz
uint32_t pulse4_value = 2000; // 4000hz

uint32_t ccr_content;
TIM_HandleTypeDef tim2;

int main(void)
{
	HAL_Init();
	GPIO_SWO();
	SysClk_config();
	Timer2_init();
	printf("%lu\n",HAL_RCC_GetPCLK1Freq());
	if(HAL_TIM_OC_Start_IT(&tim2, TIM_CHANNEL_1) != HAL_OK) Error_handler();
	if(HAL_TIM_OC_Start_IT(&tim2, TIM_CHANNEL_2) != HAL_OK) Error_handler();
	if(HAL_TIM_OC_Start_IT(&tim2, TIM_CHANNEL_3) != HAL_OK) Error_handler();
	if(HAL_TIM_OC_Start_IT(&tim2, TIM_CHANNEL_4) != HAL_OK) Error_handler();
	while(1);

}

void Timer2_init(void)
{

	tim2.Instance = TIM2;
	tim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	tim2.Init.Period = 0xFFFFFFFF;
	tim2.Init.Prescaler = 0;
	if(HAL_TIM_OC_Init(&tim2) != HAL_OK) Error_handler();

	TIM_OC_InitTypeDef tim2oc_init;
	tim2oc_init.OCMode = TIM_OCMODE_TOGGLE;
	tim2oc_init.OCPolarity = TIM_OCPOLARITY_HIGH;
	tim2oc_init.Pulse = pulse1_value;
	if (HAL_TIM_OC_ConfigChannel(&tim2, &tim2oc_init, TIM_CHANNEL_1) != HAL_OK) Error_handler();
	tim2oc_init.Pulse = pulse2_value;
	if (HAL_TIM_OC_ConfigChannel(&tim2, &tim2oc_init, TIM_CHANNEL_2) != HAL_OK) Error_handler();
	tim2oc_init.Pulse = pulse3_value;
	if (HAL_TIM_OC_ConfigChannel(&tim2, &tim2oc_init, TIM_CHANNEL_3) != HAL_OK) Error_handler();
	tim2oc_init.Pulse = pulse4_value;
	if (HAL_TIM_OC_ConfigChannel(&tim2, &tim2oc_init, TIM_CHANNEL_4) != HAL_OK) Error_handler();



}

void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
	{
		ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
		__HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_1, ccr_content + pulse1_value);
	}
	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)
	{
		ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
		__HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_2, ccr_content + pulse2_value);
	}
	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3)
	{
		ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_3);
		__HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_3, ccr_content + pulse3_value);

	}
	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_4)
	{
		ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_4);
		__HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_4, ccr_content + pulse4_value);

	}
}

void SysClk_config(void)
{
	RCC_OscInitTypeDef hse;
	memset(&hse, 0, sizeof(hse));
	hse.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	hse.HSEState = RCC_HSE_ON;
	hse.PLL.PLLState = RCC_PLL_NONE;
	if(HAL_RCC_OscConfig(&hse) != HAL_OK) Error_handler();
	RCC_ClkInitTypeDef clk;
	clk.SYSCLKSource = RCC_SYSCLKSOURCE_STATUS_HSE;
	clk.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | \
			RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	clk.AHBCLKDivider = RCC_SYSCLK_DIV1;
	clk.APB1CLKDivider = RCC_HCLK_DIV1;
	HAL_RCC_ClockConfig(&clk, FLASH_ACR_LATENCY_0WS);
	__HAL_RCC_HSI_DISABLE();// always disable hsi after making hse as clock source not before that

}

void GPIO_SWO(void)
{
	__HAL_RCC_GPIOB_CLK_ENABLE();
	GPIO_InitTypeDef gpio_swo;
	gpio_swo.Mode = GPIO_MODE_AF_PP;
	gpio_swo.Pin = GPIO_PIN_3;
	gpio_swo.Alternate = GPIO_AF0_SWJ;
	gpio_swo.Pull = GPIO_NOPULL;
	gpio_swo.Speed = GPIO_SPEED_FREQ_LOW;

	HAL_GPIO_Init(GPIOB, &gpio_swo);
}

void Error_handler(void)
{
	while(1);
}
